#!/usr/bin/env kscript

//DEPS com.squareup.okhttp3:okhttp:3.14.1
//DEPS com.squareup.moshi:moshi:1.8.0
//DEPS org.nanohttpd:nanohttpd:2.2.0
//DEPS com.offbytwo:docopt:0.6.0.20150202
//DEPS com.squareup:kotlinpoet:1.4.4

import com.squareup.kotlinpoet.*
import com.squareup.moshi.Moshi
import okhttp3.OkHttpClient
import okhttp3.Request
import okio.Okio
import org.w3c.dom.Element
import java.io.File
import java.util.*
import javax.xml.parsers.DocumentBuilderFactory
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy

val rootDir = File(System.getenv("KSCRIPT_FILE")).parentFile.parentFile

fun download(url: String, file: File) {
    val client = OkHttpClient()
    val request = Request.Builder().url(url).get().build()

    file.parentFile.mkdirs()

    val response = client.newCall(request).execute()
    if (!response.isSuccessful) {
        throw Exception("cannot download $url: ${response.code()}")
    }

    response.body()!!.byteStream().use { inputStream ->
        file.outputStream().use {
            inputStream.copyTo(it)
        }
    }
}

fun updateEnums(cardsJsonFile: File, outputDir: File) {
    val moshi = Moshi.Builder().build()
    val adapter = moshi.adapter<Any>(Any::class.java)
    val hsCardList = adapter.fromJson(Okio.buffer(Okio.source(cardsJsonFile))) as List<Map<*, *>>

    val playerClassSet = TreeSet<String>()
    val raceSet = TreeSet<String>()
    val raritySet = TreeSet<String>()
    val setSet = TreeSet<String>()
    val typeSet = TreeSet<String>()
    val mechanicSet = TreeSet<String>()

    val map = TreeMap<String, ArrayList<String>>()
    for (card in hsCardList) {
        try {
            val cardName = (card["name"] as Map<String, String>)["enUS"]!!
                    .toUpperCase()
                    .replace(" ", "_")
                    .replace(Regex("[^A-Z_]"), "")

            if (!cardName.matches(Regex("_*"))) {
                map.getOrPut(cardName, { ArrayList() }).add((card["id"] as String))
            }
        } catch (e: Exception) {
            //System.out.print(e)
        }

        (card["cardClass"] as String?)?.let { playerClassSet.add(it) }
        (card["race"] as String?)?.let { raceSet.add(it) }
        (card["rarity"] as String?)?.let { raritySet.add(it) }
        (card["set"] as String?)?.let { setSet.add(it) }
        (card["type"] as String?)?.let { typeSet.add(it) }
        (card["mechanics"] as List<String>?)?.forEach {
            mechanicSet.add(it)
        }
    }

    val cardIds = HashMap<String, String>()
    val keys = TreeSet<String>(map.keys)
    for (key in keys) {
        val allIds = map[key]!!

        /*
         * there might be several cards with the same name (pyros is an example)
         * in that case, we sort by card id
         */
        allIds.sort()

        for ((i, id) in allIds.withIndex()) {
            var name = key
            if (i > 0) {
                name += i
            }
            cardIds.put(name, id)
        }
    }


    generateFile("CardId", cardIds, outputDir)

    generateEnumFile("PlayerClass", playerClassSet, outputDir)
    generateEnumFile("Race", raceSet, outputDir)
    generateEnumFile("Rarity", raritySet, outputDir)
    generateEnumFile("HSSet", setSet, outputDir)
    generateEnumFile("Mechanic", mechanicSet, outputDir)
    generateEnumFile("Type", typeSet, outputDir)
}

fun generateEnumFile(fileName: String, propertySet: Set<String>, outputDir: File) {
    generateFile(fileName, propertySet.map { it to it }.toMap(), outputDir)
}

fun generateFile(fileName: String, properties: Map<String, String>, outputDir: File) {
    val fileBuilder = FileSpec.builder("net.hearthsim.hsmodel.enum", fileName)
    fileBuilder.addComment("Generated by hsmodel")

    val typeBuilder = TypeSpec.objectBuilder(fileName)
    for (property in properties) {
        typeBuilder.addProperty(PropertySpec.builder(property.key, String::class)
                .initializer("\"" + property.value + "\"")
                .addModifiers(KModifier.CONST, KModifier.PUBLIC)
                .mutable(false)
                .build())
    }
    fileBuilder.addType(typeBuilder.build())

    fileBuilder.build().writeTo(outputDir)
}

class BattlegroundMinion(val cardId: String, val techLevel: Int)

fun generateBattlegroundsFile(minions: List<BattlegroundMinion>, outputDir: File) {
    val fileBuilder = FileSpec.builder("net.hearthsim.hsmodel.battlegrounds", "Battlegrounds")
    fileBuilder.addComment("Generated by hsmodel")

    fileBuilder.addType(TypeSpec.classBuilder("BattlegroundMinion")
            .primaryConstructor(
                    FunSpec.constructorBuilder()
                            .addParameter("cardId", String::class)
                            .addParameter("techLevel", Int::class)
                            .build()
            )
            .addProperty(
                    PropertySpec.builder("cardId", String::class)
                            .initializer("cardId")
                            .build()
            )
            .addProperty(
                    PropertySpec.builder("techLevel", Int::class)
                            .initializer("techLevel")
                            .build()
            )
            .build()
    )

    val battlegroundMinionClassName = ClassName("net.hearthsim.hsmodel.battlegrounds", "BattlegroundMinion")
    val listClassName = List::class.asClassName().parameterizedBy(battlegroundMinionClassName)

    val initializerCodeBlockBuilder = CodeBlock.builder()
            .addStatement("listOf(")
            .indent()
    minions.forEachIndexed {index, minion ->
        val comma = if (index != minions.size - 1) {
            ","
        } else {
            ""
        }
        initializerCodeBlockBuilder.addStatement("BattlegroundMinion(\"${minion.cardId}\", ${minion.techLevel})$comma")
    }
    initializerCodeBlockBuilder
            .unindent()
            .addStatement(")")

    fileBuilder.addProperty(
            PropertySpec.builder("battlegroundsMinions", listClassName)
                    .initializer(
                            initializerCodeBlockBuilder.build()
                    ).build()
    )
    minions.forEach {

    }

    fileBuilder.build().writeTo(outputDir)
}

fun updateBattlegrounds(outputDir: File) {
    val url = "https://raw.githubusercontent.com/HearthSim/hsdata/master/CardDefs.xml"

    val client = OkHttpClient()
    val request = Request.Builder().url(url).get().build()

    val response = client.newCall(request).execute()
    if (!response.isSuccessful) {
        throw Exception("cannot download $url: ${response.code()}")
    }

    val document = response.body()!!.byteStream().use { inputStream ->
        val factory = DocumentBuilderFactory.newInstance()
        val builder = factory.newDocumentBuilder()
        builder.parse(inputStream)
    }

    val entities = document.getElementsByTagName("Entity")
    val minions = mutableListOf<BattlegroundMinion>()


    entity@ for (i in 0.until(entities.length)) {
        val entity = entities.item(i) as Element
        val cardId = entity.getAttribute("CardID")

        val tags = entity.getElementsByTagName("Tag")
        var techLevel: Int? = null
        var isBaconPool = false
        tag@ for (j in 0.until(tags.length)) {
            val tag = tags.item(j) as Element
            when (tag.getAttribute("name")) {
                "TECH_LEVEL" -> techLevel = tag.getAttribute("value")?.toIntOrNull()
                "IS_BACON_POOL_MINION" -> isBaconPool = true
            }
        }

        if (cardId != null && techLevel != null && isBaconPool) {
            minions.add(BattlegroundMinion(cardId = cardId, techLevel = techLevel))
        }
    }

    generateBattlegroundsFile(minions, outputDir)
}


println("rootDir=${rootDir}")

val outputDir = File(rootDir, "kotlin-hsmodel/src/commonMain/kotlin")
val cardsJsonFile = File(rootDir, "app/src/main/res/raw/cards.json")
//download("https://api.hearthstonejson.com/v1/latest/all/cards.json", cardsJsonFile)
//updateEnums(cardsJsonFile, outputDir)

updateBattlegrounds(outputDir)