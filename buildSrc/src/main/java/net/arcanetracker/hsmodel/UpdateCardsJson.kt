package net.arcanetracker.hsmodel

import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.moshi.Moshi
import com.squareup.moshi.Types
import okhttp3.OkHttpClient
import okhttp3.Request
import okio.Okio
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction
import java.io.File
import java.util.*

open class UpdateCardsJson: DefaultTask() {
    @TaskAction
    fun taskAction() {
        val client = OkHttpClient()
        val version = 25252
        val request = Request.Builder().url("https://api.hearthstonejson.com/v1/$version/all/cards.json").build()

        val response = client.newCall(request).execute()

        if (!response.isSuccessful) {
            throw Exception()
        }

        val cardsJsonFile = File(project.projectDir, "src/main/resources/cards.json")
        response.body()?.byteStream()?.use {inputStream ->
            cardsJsonFile.outputStream().use {
                inputStream.copyTo(it)
            }
        }

        updateEnums(cardsJsonFile)
    }

    fun updateEnums(cardsJsonFile: File) {
        val moshi = Moshi.Builder().build()
        val type = Types.newParameterizedType(List::class.java, HSCard::class.java)
        val adapter = moshi.adapter<List<HSCard>>(type)
        val hsCardList = adapter.fromJson(Okio.buffer(Okio.source(cardsJsonFile)))!!

        val playerClassSet = TreeSet<String>()
        val raceSet = TreeSet<String>()
        val raritySet = TreeSet<String>()
        val setSet = TreeSet<String>()
        val typeSet = TreeSet<String>()
        val mechanicSet = TreeSet<String>()

        val map = TreeMap<String, ArrayList<String>>()
        for (card in hsCardList) {
            try {
                val cardName = card.name!!["enUS"]!!
                        .toUpperCase()
                        .replace(" ", "_")
                        .replace(Regex("[^A-Z_]"), "")

                map.getOrPut(cardName, { ArrayList() }).add(card.id)
            } catch (e: Exception) {
                //System.out.print(e)
            }

            card.cardClass?.let { playerClassSet.add(it) }
            card.race?.let { raceSet.add(it) }
            card.rarity?.let { raritySet.add(it) }
            card.set?.let { setSet.add(it) }
            card.type?.let { typeSet.add(it) }
            card.mechanics?.forEach {
                mechanicSet.add(it)
            }
        }

        val cardIds = HashMap<String, String>()
        val keys = TreeSet<String>(map.keys)
        for (key in keys) {
            val allIds = map[key]!!

            /*
             * there might be several cards with the same name (pyros is an example)
             * in that case, we sort by card id
             */
            allIds.sort()

            for ((i, id) in allIds.withIndex()) {
                var name = key
                if (i > 0) {
                    name += i
                }
                cardIds.put(name, id)
            }
        }


        val outputDir = File(project.projectDir, "src/main/java/net/mbonnin/hsmodel/enum")
        generateFile("CardId", cardIds, outputDir)

        generateEnumFile("PlayerClass", playerClassSet, outputDir)
        generateEnumFile("Race", raceSet, outputDir)
        generateEnumFile("Rarity", raritySet, outputDir)
        generateEnumFile("HSSet", setSet, outputDir)
        generateEnumFile("Mechanic", mechanicSet, outputDir)
        generateEnumFile("Type", typeSet, outputDir)
    }

    companion object {
        private fun generateEnumFile(fileName: String, propertySet: Set<String>, outputDir: File) {
            generateFile(fileName, propertySet.map { it to it }.toMap(), outputDir)
        }

        private fun generateFile(fileName: String, properties: Map<String, String>, outputDir: File) {
            val fileBuilder = FileSpec.builder("net.mbonnin.hsmodel", fileName)
            fileBuilder.addComment("Generated by hsmodel")

            val typeBuilder = TypeSpec.objectBuilder(fileName)
            for (property in properties) {
                typeBuilder.addProperty(PropertySpec.builder(property.key, String::class)
                        .initializer("\"" + property.value + "\"")
                        .addModifiers(KModifier.CONST, KModifier.PUBLIC)
                        .mutable(false)
                        .build())
            }
            fileBuilder.addType(typeBuilder.build())

            fileBuilder.build().writeTo(outputDir)
        }
    }
}